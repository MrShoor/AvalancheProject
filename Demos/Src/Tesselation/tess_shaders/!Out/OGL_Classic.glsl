{
 "Vertex": "#version 400\r\nstruct vec1 {\r\n\tfloat x;\r\n};\r\nstruct uvec1 {\r\n\tuint x;\r\n};\r\nstruct ivec1 {\r\n\tint x;\r\n};\r\nuniform \tmat4x4 M_Matrix;\r\nuniform \tmat4x4 MVP_Matrix;\r\nuniform \tmat4x4 MV_Matrix;\r\nuniform \tmat4x4 P_Matrix;\r\nuniform \tmat4x4 M_InverseMatrix;\r\nuniform \tmat4x4 MVP_InverseMatrix;\r\nuniform \tmat4x4 MV_InverseMatrix;\r\nuniform \tmat4x4 P_InverseMatrix;\r\nuniform \tmat4x4 VP_Matrix;\r\nuniform \tmat4x4 VP_InverseMatrix;\r\nuniform \tmat4x4 V_Matrix;\r\nuniform \tmat4x4 V_InverseMatrix;\r\nuniform \tvec2 FBOFlip;\r\nvec4 Input0;\r\n in  vec3 in_vsCoord0;\r\nvec4 Input1;\r\n in  vec3 in_vsNormal0;\r\n#undef Output0\r\n#define Output0 phase0_Output0\r\nvec4 phase0_Output0;\r\n out  vec3 Normal0;\r\nvec4 Output1;\r\n out  vec3 ViewPos0;\r\nvec4 Output2;\r\nvec4 Temp[1];\r\nivec4 Temp_int[1];\r\nuvec4 Temp_uint[1];\r\nvoid main()\r\n{\r\n    Input0.xyz = in_vsCoord0.xyz;\r\n    Input1.xyz = in_vsNormal0.xyz;\r\n    Temp[0] = Input0.yyyy * VP_Matrix[1].xyzw;\r\n    Temp[0] = Input0.xxxx * VP_Matrix[0].xyzw + Temp[0];\r\n    Temp[0] = Input0.zzzz * VP_Matrix[2].xyzw + Temp[0];\r\n    Output0 = Temp[0] + VP_Matrix[3].xyzw;\r\n    Temp[0].xyz = Input1.yyy * V_Matrix[1].xyz;\r\n    Temp[0].xyz = Input1.xxx * V_Matrix[0].xyz + Temp[0].xyz;\r\n    Output1.xyz = Input1.zzz * V_Matrix[2].xyz + Temp[0].xyz;\r\n    Temp[0].xyz = Input0.yyy * V_Matrix[1].xyz;\r\n    Temp[0].xyz = Input0.xxx * V_Matrix[0].xyz + Temp[0].xyz;\r\n    Temp[0].xyz = Input0.zzz * V_Matrix[2].xyz + Temp[0].xyz;\r\n    Output2.xyz = Temp[0].xyz + V_Matrix[3].xyz;\r\n    gl_Position = vec4(phase0_Output0);\r\nNormal0.xyz = Output1.xyz;\r\nViewPos0.xyz = Output2.xyz;\r\n    return;\r\n}\r\n",
 "TessEval": "#version 400\r\nstruct vec1 {\r\n\tfloat x;\r\n};\r\nstruct uvec1 {\r\n\tuint x;\r\n};\r\nstruct ivec1 {\r\n\tint x;\r\n};\r\nlayout(triangles) in;\r\nvec4 Input0[gl_MaxPatchVertices];\r\nin  vec4 SV_Position0 [gl_MaxPatchVertices];\r\nvec3 Input1[gl_MaxPatchVertices];\r\nin  vec3 hsNormal0 [gl_MaxPatchVertices];\r\nvec3 Input2[gl_MaxPatchVertices];\r\nin  vec3 hsViewPos0 [gl_MaxPatchVertices];\r\n#undef Output0\r\n#define Output0 phase0_Output0\r\nvec4 phase0_Output0;\r\nout vec3 dsNormal0;\r\n#define Output1 dsNormal0\r\nout vec3 dsViewPos0;\r\n#define Output2 dsViewPos0\r\nvec4 Temp[1];\r\nivec4 Temp_int[1];\r\nuvec4 Temp_uint[1];\r\nvoid main()\r\n{\r\n    Input1[2] = hsNormal0[2];\r\n    Input1[1] = hsNormal0[1];\r\n    Input1[0] = hsNormal0[0];\r\n    Input2[2] = hsViewPos0[2];\r\n    Input2[1] = hsViewPos0[1];\r\n    Input2[0] = hsViewPos0[0];\r\n    Temp[0] = gl_TessCoord.yyyy * gl_in[1].gl_Position;\r\n    Temp[0] = gl_TessCoord.xxxx * gl_in[0].gl_Position + Temp[0];\r\n    Output0 = gl_TessCoord.zzzz * gl_in[2].gl_Position + Temp[0];\r\n    Temp[0].xyz = gl_TessCoord.yyy * Input1[1].xyz;\r\n    Temp[0].xyz = gl_TessCoord.xxx * Input1[0].xyz + Temp[0].xyz;\r\n    Output1.xyz = gl_TessCoord.zzz * Input1[2].xyz + Temp[0].xyz;\r\n    Temp[0].xyz = gl_TessCoord.yyy * Input2[1].xyz;\r\n    Temp[0].xyz = gl_TessCoord.xxx * Input2[0].xyz + Temp[0].xyz;\r\n    Output2.xyz = gl_TessCoord.zzz * Input2[2].xyz + Temp[0].xyz;\r\n    gl_Position = vec4(phase0_Output0);\r\n    return;\r\n}\r\n",
 "Fragment": "#version 400\r\nstruct vec1 {\r\n\tfloat x;\r\n};\r\nstruct uvec1 {\r\n\tuint x;\r\n};\r\nstruct ivec1 {\r\n\tint x;\r\n};\r\nvec4 Input1;\r\n in  vec3 dsNormal0;\r\nvec4 Input2;\r\n in  vec3 dsViewPos0;\r\nlayout(location = 0) out  vec4 SV_Target0;\r\n#define Output0 SV_Target0\r\nvec4 Temp[2];\r\nivec4 Temp_int[2];\r\nuvec4 Temp_uint[2];\r\nvoid main()\r\n{\r\n    Input1.xyz = dsNormal0.xyz;\r\n    Input2.xyz = dsViewPos0.xyz;\r\n    Temp[0].x = dot(Input1.xyz, Input1.xyz);\r\n    Temp[0].x = inversesqrt(Temp[0].x);\r\n    Temp[0].xyz = Temp[0].xxx * Input1.xyz;\r\n    Temp[0].w = dot((-Input2.xyz), (-Input2.xyz));\r\n    Temp[0].w = inversesqrt(Temp[0].w);\r\n    Temp[1].xyz = Temp[0].www * (-Input2.xyz);\r\n    Temp[0].x = dot(Temp[1].xyz, Temp[0].xyz);\r\n    Output0.xyz = max(Temp[0].xxx, vec3(intBitsToFloat(0x0), intBitsToFloat(0x0), intBitsToFloat(0x0)));\r\n    Output0.w = intBitsToFloat(0x3F800000);\r\n    return;\r\n}\r\n",
 "Name": "Classic",
 "TessControl": "#version 400\r\nstruct vec1 {\r\n\tfloat x;\r\n};\r\nstruct uvec1 {\r\n\tuint x;\r\n};\r\nstruct ivec1 {\r\n\tint x;\r\n};\r\nlayout(vertices=3) out;\r\n\/\/control_point_phase declarations\r\nvec4 Input0[gl_MaxPatchVertices];\r\nin  vec4 SV_Position0 [gl_MaxPatchVertices];\r\nvec3 Input1[gl_MaxPatchVertices];\r\nin  vec3 Normal0 [gl_MaxPatchVertices];\r\nvec3 Input2[gl_MaxPatchVertices];\r\nin  vec3 ViewPos0 [gl_MaxPatchVertices];\r\n#undef Output0\r\n#define Output0 phase2_Output0\r\nvec4 phase2_Output0;\r\nout vec3 hsNormal0[];\r\n#define Output1 hsNormal0[gl_InvocationID]\r\nout vec3 hsViewPos0[];\r\n#define Output2 hsViewPos0[gl_InvocationID]\r\nvec4 Temp[1];\r\nivec4 Temp_int[1];\r\nuvec4 Temp_uint[1];\r\nvoid control_point_phase0()\r\n{\r\n    Temp[0].x = intBitsToFloat(gl_InvocationID + 0x1);\r\n    \/\/null = uintBitsToFloat(floatBitsToUint(Temp[0]).x \/ 3u);\r\n    Temp[0].x = uintBitsToFloat(floatBitsToUint(Temp[0]).x % 3u);\r\n    Output0 = gl_in[floatBitsToInt(Temp[0]).x].gl_Position;\r\n    Output1.xyz = Input1[floatBitsToInt(Temp[0]).x].xyz;\r\n    Output2.xyz = Input2[floatBitsToInt(Temp[0]).x].xyz;\r\n    gl_out[gl_InvocationID].gl_Position = vec4(phase2_Output0);\r\n}\r\n\/\/fork_phase declarations\r\nconst int HullPhase0InstanceCount = 3;\r\n#undef Output0\r\n#define Output0 phase3_Output0\r\nvec4 phase3_Output0[3];\r\nvoid fork_phase0()\r\n{\r\nfor(int forkInstanceID = 0; forkInstanceID < HullPhase0InstanceCount; ++forkInstanceID) {\r\n    Temp[0].x = intBitsToFloat(forkInstanceID);\r\n    Output0[floatBitsToInt(Temp[0]).x].x = intBitsToFloat(int(0x40A00000));\r\n}\r\ngl_TessLevelOuter[0] = float(phase3_Output0[0].x);\r\ngl_TessLevelOuter[1] = float(phase3_Output0[1].x);\r\ngl_TessLevelOuter[2] = float(phase3_Output0[2].x);\r\n}\r\n\/\/fork_phase declarations\r\n#undef Output3\r\n#define Output3 phase3_Output3\r\nvec4 phase3_Output3;\r\nvoid fork_phase1()\r\n{\r\nOutput3.x = intBitsToFloat(int(0x40A00000));\r\ngl_TessLevelOuter[0] = float(phase3_Output0[0].x);\r\ngl_TessLevelOuter[1] = float(phase3_Output0[1].x);\r\ngl_TessLevelOuter[2] = float(phase3_Output0[2].x);\r\ngl_TessLevelInner[0] = float(phase3_Output3.x);\r\n}\r\nvoid main()\r\n{\r\n    Input1[2] = Normal0[2];\r\n    Input1[1] = Normal0[1];\r\n    Input1[0] = Normal0[0];\r\n    Input2[2] = ViewPos0[2];\r\n    Input2[1] = ViewPos0[1];\r\n    Input2[0] = ViewPos0[0];\r\n  control_point_phase0();\r\n  barrier();\r\n  if (gl_InvocationID == 2) {\r\n    fork_phase0();\r\n    fork_phase1();\r\n  }\r\n}\r\n"
}