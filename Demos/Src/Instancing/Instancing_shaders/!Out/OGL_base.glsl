{
 "Vertex": "#version 330\r\nstruct vec1 {\r\n\tfloat x;\r\n};\r\nstruct uvec1 {\r\n\tuint x;\r\n};\r\nstruct ivec1 {\r\n\tint x;\r\n};\r\nuniform \tmat4x4 M_Matrix;\r\nuniform \tmat4x4 MVP_Matrix;\r\nuniform \tmat4x4 MV_Matrix;\r\nuniform \tmat4x4 P_Matrix;\r\nuniform \tmat4x4 M_InverseMatrix;\r\nuniform \tmat4x4 MVP_InverseMatrix;\r\nuniform \tmat4x4 MV_InverseMatrix;\r\nuniform \tmat4x4 P_InverseMatrix;\r\nuniform \tmat4x4 VP_Matrix;\r\nuniform \tmat4x4 VP_InverseMatrix;\r\nuniform \tmat4x4 V_Matrix;\r\nuniform \tmat4x4 V_InverseMatrix;\r\n in  vec3 in_vsCoord0;\r\nvec3 Input0;\r\n in  vec3 in_vsNormal0;\r\nvec3 Input1;\r\n in  vec3 in_aiPosition0;\r\nvec3 Input2;\r\n in  vec4 in_aiColor0;\r\nvec4 Input3;\r\n#undef Output0\r\n#define Output0 phase0_Output0\r\nvec4 phase0_Output0;\r\n out  vec3 Normal0;\r\nvec4 Output1;\r\n out  vec3 ViewPos0;\r\nvec4 Output2;\r\n out  vec4 Color0;\r\nvec4 Output3;\r\nvec4 Temp[2];\r\nivec4 Temp_int[2];\r\nuvec4 Temp_uint[2];\r\nvoid main()\r\n{\r\n    Input0 = in_vsCoord0;\r\n    Input1 = in_vsNormal0;\r\n    Input2 = in_aiPosition0;\r\n    Input3 = in_aiColor0;\r\n    Temp[0].xyz = Input0.xyz + Input2.xyz;\r\n    Temp[1] = Temp[0].yyyy * VP_Matrix[1].xyzw;\r\n    Temp[1] = Temp[0].xxxx * VP_Matrix[0].xyzw + Temp[1];\r\n    Temp[1] = Temp[0].zzzz * VP_Matrix[2].xyzw + Temp[1];\r\n    Output0 = Temp[1] + VP_Matrix[3].xyzw;\r\n    Temp[1].xyz = Input1.yyy * V_Matrix[1].xyz;\r\n    Temp[1].xyz = Input1.xxx * V_Matrix[0].xyz + Temp[1].xyz;\r\n    Output1.xyz = Input1.zzz * V_Matrix[2].xyz + Temp[1].xyz;\r\n    Temp[1].xyz = Temp[0].yyy * V_Matrix[1].xyz;\r\n    Temp[0].xyw = Temp[0].xxx * V_Matrix[0].xyz + Temp[1].xyz;\r\n    Temp[0].xyz = Temp[0].zzz * V_Matrix[2].xyz + Temp[0].xyw;\r\n    Output2.xyz = Temp[0].xyz + V_Matrix[3].xyz;\r\n    Output3 = Input3;\r\n    gl_Position = vec4(phase0_Output0);\r\nNormal0.xyz = Output1.xyz;\r\nViewPos0.xyz = Output2.xyz;\r\nColor0 = Output3;\r\n    return;\r\n}\r\n",
 "Fragment": "#version 330\r\nstruct vec1 {\r\n\tfloat x;\r\n};\r\nstruct uvec1 {\r\n\tuint x;\r\n};\r\nstruct ivec1 {\r\n\tint x;\r\n};\r\n in  vec3 Normal0;\r\nvec3 Input1;\r\n in  vec3 ViewPos0;\r\nvec3 Input2;\r\n in  vec4 Color0;\r\nvec4 Input3;\r\nlayout(location = 0) out  vec4 SV_Target0;\r\n#define Output0 SV_Target0\r\nvec4 Temp[2];\r\nivec4 Temp_int[2];\r\nuvec4 Temp_uint[2];\r\nvoid main()\r\n{\r\n    Input1 = Normal0;\r\n    Input2 = ViewPos0;\r\n    Input3 = Color0;\r\n    Temp[0].x = dot(Input1.xyz, Input1.xyz);\r\n    Temp[0].x = inversesqrt(Temp[0].x);\r\n    Temp[0].xyz = Temp[0].xxx * Input1.xyz;\r\n    Temp[0].w = dot(Input2.xyz, Input2.xyz);\r\n    Temp[0].w = inversesqrt(Temp[0].w);\r\n    Temp[1].xyz = Temp[0].www * Input2.xyz;\r\n    Temp[0].x = dot(Temp[1].xyz, Temp[0].xyz);\r\n    Temp[0].x = max((-Temp[0].x), intBitsToFloat(0x0));\r\n    Output0 = Temp[0].xxxx * Input3;\r\n    return;\r\n}\r\n",
 "Name": "base"
}